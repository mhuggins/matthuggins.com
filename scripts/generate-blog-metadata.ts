#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { parse as parseYaml } from "yaml";

const __filename = path.basename(fileURLToPath(import.meta.url));
const __dirname = path.dirname(fileURLToPath(import.meta.url));
const projectRoot = path.join(__dirname, "..");
const contentDir = path.join(projectRoot, "src/content/blog");
const relativePath = path.join(path.relative(projectRoot, __dirname), __filename);

interface RawFrontmatter {
  title?: string;
  date?: string;
  tags?: string[];
  summary?: string;
  note?: string;
  [key: string]: unknown;
}

interface ProcessedPost {
  slug: string;
  filePath: string;
  title: string;
  date: string;
  summary: string | null;
  note: string | null;
  tags: string[];
}

const autogeneratedComment = `// Auto-generated metadata - do not edit manually
// Generated by ${relativePath}`;

/**
 * Simple frontmatter parser that extracts YAML between --- delimiters
 */
function parseFrontmatter(content: string): RawFrontmatter | null {
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
  if (!frontmatterMatch) {
    return null;
  }

  try {
    return parseYaml(frontmatterMatch[1]) as RawFrontmatter;
  } catch (error) {
    console.error("Error parsing YAML frontmatter:", (error as Error).message);
    return null;
  }
}

/**
 * Extract frontmatter from all blog posts and generate metadata JSON
 */
function generateBlogMetadata(): void {
  console.log("ðŸ” Scanning for blog posts...");

  if (!fs.existsSync(contentDir)) {
    console.warn("âš ï¸  Blog content directory not found:", contentDir);
    return;
  }

  const posts: ProcessedPost[] = [];
  const files = getAllMarkdownFiles(contentDir);

  console.log(`ðŸ“ Found ${files.length} markdown files`);

  for (const filePath of files) {
    try {
      const content = fs.readFileSync(filePath, "utf8");
      const frontmatter = parseFrontmatter(content);

      // Generate slug from file path
      const relativePath = path.relative(contentDir, filePath);
      const slug = relativePath
        .replace(/\.(md|mdx)$/i, "")
        .replace(/\\/g, "/") // Normalize path separators
        .replace(/\/index$/, ""); // Handle index files

      // Validate required frontmatter fields
      if (!frontmatter?.title || !frontmatter?.date) {
        console.warn(`âš ï¸  Skipping ${relativePath}: missing title or date`);
        continue;
      }

      posts.push({
        slug,
        filePath: relativePath,
        title: frontmatter.title,
        date: frontmatter.date,
        summary: frontmatter.summary || null,
        note: frontmatter.note || null,
        tags: frontmatter.tags || [],
      });
    } catch (error) {
      console.error(`âŒ Error processing ${filePath}:`, (error as Error).message);
    }
  }

  // Sort posts by date (newest first)
  posts.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());

  console.log(`âœ… Processed ${posts.length} valid blog posts`);

  // Generate TypeScript file with proper typing
  // Ensure output directory exists
  const tsOutputPath = path.join(projectRoot, "src/data/blog-metadata.gen.ts");
  const outputDir = path.dirname(tsOutputPath);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  const allTags = [...new Set(posts.flatMap((post) => post.tags))];
  const tsContent = `${autogeneratedComment}

import type { BlogPostMetadata, BlogTag } from "@/types/blog.gen";

export const blogTags: ReadonlySet<BlogTag> = new Set(${JSON.stringify(allTags, null, 2)});

export const blogMetadata: readonly BlogPostMetadata[] = ${JSON.stringify(posts, null, 2)};
`;

  fs.writeFileSync(tsOutputPath, tsContent);
  console.log(`ðŸ“¦ Generated metadata: ${tsOutputPath}`);

  // Generate TypeScript types
  generateTypes(posts);
}

/**
 * Recursively find all markdown files
 */
function getAllMarkdownFiles(dir: string): string[] {
  const files: string[] = [];
  const items = fs.readdirSync(dir);

  for (const item of items) {
    const fullPath = path.join(dir, item);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      files.push(...getAllMarkdownFiles(fullPath));
    } else if (/\.(md|mdx)$/i.test(item)) {
      files.push(fullPath);
    }
  }

  return files;
}

/**
 * Generate TypeScript type definitions
 */
function generateTypes(posts: ProcessedPost[]): void {
  const typesPath = path.join(projectRoot, "src/types/blog.gen.ts");

  // Extract unique tags for type safety
  const allTags = [...new Set(posts.flatMap((post) => post.tags))];

  // Ensure directory exists
  const typesDir = path.dirname(typesPath);
  if (!fs.existsSync(typesDir)) {
    fs.mkdirSync(typesDir, { recursive: true });
  }

  const typeDefinition = `${autogeneratedComment}

export interface BlogPostMetadata {
  slug: string;
  filePath: string;
  title: string;
  date: string;
  summary: string | null;
  note: string | null;
  tags: BlogTag[];
}

export type BlogTag = ${allTags.length > 0 ? allTags.map((tag) => `"${tag}"`).join(" | ") : "string"};
`;

  fs.writeFileSync(typesPath, typeDefinition);
  console.log(`ðŸ”§ Generated TypeScript types: ${typesPath}`);
}

// Run the script
generateBlogMetadata();
